package main

import (
	"bufio"
	"fmt"
	"net"
	"sort"
	"strings"
	"sync"
	"time"
)

// Estructura para almacenar información del puerto
type PortInfo struct {
	Port     int
	State    string
	Service  string
	Banner   string
	Protocol string
}

func main() {
	target := "192.168.1.1"
	startTime := time.Now()
	
	fmt.Printf("Starting Nmap-style scan against %s\n", target)
	fmt.Println("=====================================================")
	
	// Ajustes para optimizar la detección
	maxConcurrency := 500
	connectTimeout := 200 * time.Millisecond
	bannerTimeout := 1 * time.Second
	
	// Estructura para almacenar la información de los puertos
	var mu sync.Mutex
	portResults := make(map[int]*PortInfo)
	
	// Control de concurrencia
	var wg sync.WaitGroup
	semaphore := make(chan struct{}, maxConcurrency)
	
	// Mapeo común de puertos a servicios
	commonServices := map[int]string{
		21:   "ftp",
		22:   "ssh",
		23:   "telnet",
		25:   "smtp",
		53:   "domain",
		80:   "http",
		110:  "pop3",
		111:  "rpcbind",
		135:  "msrpc",
		139:  "netbios-ssn",
		143:  "imap",
		443:  "https",
		445:  "microsoft-ds",
		993:  "imaps",
		995:  "pop3s",
		1723: "pptp",
		3306: "mysql",
		3389: "ms-wbt-server",
		5900: "vnc",
		8080: "http-proxy",
		3517: "unknown",
	}
	
	// Función para intentar obtener el banner de un servicio
	getBanner := func(ip string, port int) string {
		address := fmt.Sprintf("%s:%d", ip, port)
		conn, err := net.DialTimeout("tcp", address, connectTimeout)
		if err != nil {
			return ""
		}
		defer conn.Close()
		
		// Establecer timeout para leer el banner
		err = conn.SetDeadline(time.Now().Add(bannerTimeout))
		if err != nil {
			return ""
		}
		
		// Para algunos servicios, enviar una solicitud para provocar una respuesta
		switch port {
		case 80, 8080, 443:
			// Enviar solicitud HTTP
			_, err = fmt.Fprintf(conn, "GET / HTTP/1.0\r\nHost: %s\r\n\r\n", ip)
		case 21:
			// FTP no necesita estímulo, suele enviar banner automáticamente
		case 22:
			// SSH envía banner automáticamente
		case 25, 587:
			// SMTP envía banner automáticamente
		case 110:
			// POP3 envía banner automáticamente
		}
		
		if err != nil {
			return ""
		}
		
		// Leer respuesta
		scanner := bufio.NewScanner(conn)
		if scanner.Scan() {
			return strings.TrimSpace(scanner.Text())
		}
		
		return ""
	}
	
	// Función para determinar el servicio basado en el banner
	identifyService := func(port int, banner string) string {
		// Primero intentar con el mapeo conocido
		if service, ok := commonServices[port]; ok {
			return service
		}
		
		// Si tenemos un banner, intentar identificar por contenido
		lowerBanner := strings.ToLower(banner)
		
		if strings.Contains(lowerBanner, "ssh") {
			return "ssh"
		} else if strings.Contains(lowerBanner, "http") {
			return "http"
		} else if strings.Contains(lowerBanner, "ftp") {
			return "ftp"
		} else if strings.Contains(lowerBanner, "smtp") {
			return "smtp"
		} else if strings.Contains(lowerBanner, "pop3") {
			return "pop3"
		} else if strings.Contains(lowerBanner, "imap") {
			return "imap"
		} else if strings.Contains(lowerBanner, "mysql") {
			return "mysql"
		} else if strings.Contains(lowerBanner, "vnc") {
			return "vnc"
		}
		
		return "unknown"
	}
	
	// Función para escanear un puerto
	scanPort := func(port int) {
		defer wg.Done()
		defer func() { <-semaphore }()
		
		address := fmt.Sprintf("%s:%d", target, port)
		conn, err := net.DialTimeout("tcp", address, connectTimeout)
		
		if err == nil {
			// Puerto abierto, obtener banner
			conn.Close() // Cerrar esta conexión para abrir una nueva para el banner
			
			banner := getBanner(target, port)
			service := identifyService(port, banner)
			
			mu.Lock()
			portResults[port] = &PortInfo{
				Port:     port,
				State:    "open",
				Service:  service,
				Banner:   banner,
				Protocol: "tcp",
			}
			mu.Unlock()
		}
	}
	
	// Generar los 1000 puertos a escanear
	portsToScan := []int{}
	
	// Primero añadir puertos prioritarios comunes
	priorityPorts := []int{21, 22, 23, 25, 53, 80, 110, 111, 135, 139, 143, 443, 445, 993, 995, 1723, 3306, 3389, 5900, 8080, 3517}
	portsToScan = append(portsToScan, priorityPorts...)
	
	// Añadir puertos restantes hasta llegar a 1000
	priorityPortsMap := make(map[int]bool)
	for _, port := range priorityPorts {
		priorityPortsMap[port] = true
	}
	
	// Añadir puertos del 1 al 1024 (bien conocidos)
	for port := 1; port <= 1024; port++ {
		if !priorityPortsMap[port] {
			portsToScan = append(portsToScan, port)
		}
	}
	
	// Añadir otros puertos comunes hasta llegar a 1000
	otherCommonPorts := []int{
		1080, 1433, 1434, 1521, 2000, 2001, 2049, 2082, 2083, 2086, 2087, 2095, 2096,
		2222, 2375, 2376, 2379, 2380, 3000, 3001, 3128, 3260, 3299, 3307, 3316, 3690,
		4000, 4001, 4040, 4044, 4369, 4444, 4445, 4505, 4506, 4730, 4848, 4949, 5000,
		5001, 5009, 5060, 5061, 5432, 5632, 5672, 5800, 5801, 5858, 5901, 5984, 5985,
		5986, 6000, 6001, 6002, 6003, 6060, 6061, 6379, 6666, 7000, 7001, 7002, 7070,
		7077, 7080, 7443, 7447, 7474, 7547, 7657, 7777, 7779, 8000, 8001, 8002, 8008,
		8009, 8010, 8081, 8082, 8083, 8089, 8090, 8140, 8181, 8333, 8443, 8834, 8880,
		8888, 8983, 9000, 9001, 9042, 9043, 9060, 9080, 9090, 9091, 9200, 9300, 9389,
		9418, 9443, 9990, 9999, 10000, 10050, 10051, 10250, 10443, 11211, 11214, 11215,
		12000, 12345, 12443, 16080, 18080, 18081, 18090, 19999, 20000, 27017, 27018,
		27019, 28017, 32768, 32769, 32770, 32771, 49152, 49153, 49154, 49155, 49156, 49157,
	}
	
	for _, port := range otherCommonPorts {
		if !priorityPortsMap[port] && len(portsToScan) < 1000 {
			portsToScan = append(portsToScan, port)
		}
	}
	
	// Limitar a 1000 puertos
	if len(portsToScan) > 1000 {
		portsToScan = portsToScan[:1000]
	}
	
	// Escanear todos los puertos
	fmt.Printf("Scanning %d most common TCP ports...\n\n", len(portsToScan))
	
	for _, port := range portsToScan {
		wg.Add(1)
		semaphore <- struct{}{}
		go scanPort(port)
	}
	
	// Esperar a que se completen todos los escaneos
	wg.Wait()
	
	// Convertir resultados a slice ordenado
	var openPorts []int
	for port := range portResults {
		openPorts = append(openPorts, port)
	}
	sort.Ints(openPorts)
	
	// Calcular estadísticas
	scanDuration := time.Since(startTime)
	
	// Imprimir cabecera estilo Nmap
	fmt.Printf("\nScan completed in %s\n", scanDuration)
	fmt.Printf("Nmap scan report for %s\n", target)
	fmt.Printf("Host is up (%.3f latency).\n", float64(scanDuration.Milliseconds())/1000.0)
	fmt.Printf("Not shown: %d closed ports\n", len(portsToScan)-len(openPorts))
	fmt.Println("PORT     STATE  SERVICE     VERSION")
	
	// Imprimir resultados detallados
	for _, port := range openPorts {
		info := portResults[port]
		bannerInfo := ""
		if info.Banner != "" {
			if len(info.Banner) > 40 {
				bannerInfo = info.Banner[:40] + "..."
			} else {
				bannerInfo = info.Banner
			}
		}
		
		fmt.Printf("%-8d %-6s %-12s %s\n", port, info.State, info.Service, bannerInfo)
	}
	
	// Imprimir resumen
	fmt.Printf("\nService detection performed. %d services on %d ports\n", len(openPorts), len(portsToScan))
	fmt.Printf("Scan done: 1 IP address (1 host up) scanned in %s\n", scanDuration)
}
